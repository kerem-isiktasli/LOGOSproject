# 우선순위 계산 모듈

> **최종 업데이트**: 2026-01-07
> **코드 위치**: `src/core/priority.ts`
> **상태**: 활성
> **이론적 기초**: THEORETICAL-FOUNDATIONS.md, FINAL-SPEC.md

---

## 맥락 및 목적

### 이 모듈이 존재하는 이유

우선순위 계산 모듈은 언어 학습에서 가장 근본적인 질문에 답합니다: **다음에 무엇을 배워야 하는가?**

우선순위 공식:
```
우선순위 = (w_F × F + w_R × R + w_E × E) / 비용
```

여기서:
- **F (Frequency, 빈도)**: 대상 텍스트에서 단어가 얼마나 자주 나타나는지 (0-1)
- **R (Relational Density, 관계 밀도)**: PMI 분석의 허브 점수 (0-1)
- **E (Contextual Contribution, 맥락적 기여)**: 의미의 중요성 (0-1)
- **비용**: 전이와 능력에 맞게 조정된 학습 난이도

---

## FRE 프레임워크

### F: 빈도 - 기초

고빈도 단어는 이해로 가는 가장 빠른 경로를 제공합니다. 상위 2,000개 단어가 텍스트의 ~80%를 커버합니다.

**예시**: "the", "is", "have"는 거의 모든 문장에 나타납니다. 이것을 먼저 배우면 즉시 이해가 향상됩니다.

### R: 관계 밀도 - 네트워크 효과

"take"와 같은 허브 단어는 수십 개의 구에 연결됩니다. 이것을 배우면 어휘 "힘의 승수"가 생깁니다.

**예시**: "take"를 알면 "take off", "take over", "take in", "take up" 등을 더 쉽게 배울 수 있습니다.

### E: 맥락적 기여 - 의미 제공자

무거운 의미 부담을 지는 단어. 고급 학습자는 정밀 어휘가 필요합니다.

**예시**: "nevertheless"는 드물지만 학술 텍스트에서 중요한 논리적 관계를 표시합니다.

---

## 비용 계산

```
비용 = 기본난이도 - 전이이득 + 노출필요
```

- **기본난이도**: 로짓 척도에서 정규화된 IRT 난이도
- **전이이득**: L1 동족어 이점 (L1이 지정되면 0.1)
- **노출필요**: 능력 격차 = max(0, 항목난이도 - 사용자Theta) / 3

최소 비용 하한: 0.1 (0으로 나누기 방지)

---

## 긴급도: 간격반복 레이어

```
최종점수 = 우선순위 × (1 + 긴급도)
```

긴급도 규칙:
- 아직 예정 아님: 0
- 오늘 예정: 1
- N일 지연됨: min(3, 1 + N × 0.5)
- 새 항목: 1.5

**쉬운 설명**: 긴급도는 복습해야 할 항목을 대기열의 위로 밀어올립니다. 많이 지연될수록 더 긴급합니다.

---

## 수준별 가중치 조정

| 수준 | Theta | F | R | E |
|------|-------|---|---|---|
| 초급 | < -1 | 0.5 | 0.25 | 0.25 |
| 중급 | -1 ~ +1 | 0.4 | 0.3 | 0.3 |
| 고급 | > +1 | 0.3 | 0.3 | 0.4 |

**이론적 근거**:
- **초급자**는 빈도를 우선시 - 핵심 어휘가 먼저
- **고급자**는 맥락적 기여를 우선시 - 정밀성과 뉘앙스 필요

---

## 세션 균형

```typescript
getSessionItems(queue, sessionSize, newItemRatio = 0.3)
```

기본값: 70% 예정 항목, 30% 새 항목.

다음을 방지:
- 모두 복습 (진전 없음)
- 모두 새 항목 (기억 유지 없음)

---

## 통합 지점

### 의존성 (암시적)
- `irt.ts`: irtDifficulty 필드 제공
- `fsrs.ts`: nextReview 날짜 제공
- `pmi.ts`: relationalDensity 점수 공급

### 의존처
- 세션 관리: 학습 대기열 구축
- UI: 대기열 위치 표시
- 분석: 우선순위 분포 표시

---

## 사용 예시

```typescript
import { computePriority, buildLearningQueue, getSessionItems } from './priority';

// 단일 단어 우선순위 계산
const priority = computePriority(word, userState);

// 완전한 대기열 구축
const queue = buildLearningQueue(objects, userState, masteryMap, new Date());

// 균형 잡힌 세션 가져오기
const session = getSessionItems(queue, 20, 0.3);
```

---

## 대기열 시각화

```
우선순위 점수
     |
     |  * 고빈도 + 오늘 예정
     |    * 중빈도 + 지연됨
     |      * 허브 단어 + 새로움
     |        * 저빈도 + 높은 E
     |          * 새 항목
     |            * 미래 예정
     +---------------------------------> 대기열 위치
```

---

*이 문서는 다음을 미러링합니다: `src/core/priority.ts`*
